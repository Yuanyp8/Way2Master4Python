
   * [封装解构](#封装解构)
      * [回顾下元组](#回顾下元组)
      * [交换问题](#交换问题)
         * [将a和b交换值](#将a和b交换值)
         * [封装解构实现](#封装解构实现)
      * [定义](#定义)
         * [封装(装箱)](#封装装箱)
         * [解构(拆箱)](#解构拆箱)
         * [对于非线性解构也没有问题](#对于非线性解构也没有问题)
      * [剩余参数](#剩余参数)
      * [嵌套模式的解构](#嵌套模式的解构)
      * [丢弃变量](#丢弃变量)
         * [举例](#举例)


## 回顾下元组

定义一个元组

```python
>>> t1 = (1,2,3)
>>> type(t1)
<class 'tuple'>
```

这样再定义一个元组

```python
>>> t2 = 5,6,7
>>> type(t2)
<class 'tuple'>
```

>- 上面的过程就是一个封装过程。对于赋值运算

- 先计算等式右边再计算左面
- 5，6，7会先转化为元组的格式
- 再把这个touple赋值给t2

## 交换问题

### 将a和b交换值

需要用到一个中间变量

```python
>>> a = 1
>>> b = 2
>>> temp = a
>>> a = b
>>> b = temp
>>> a,b
(2, 1)
```

### 封装解构实现

```python
>>> c = 1
>>> d = 2
>>> c,d = d,c
>>> c
2
>>> d
1
```

具体实现过程如下:

1. `c,d = d,c`会先计算等式右边，形成一个临时touple(2,1)
2. 再来计算等式左面，c,d = (2,1)
3. 这时候需要解构，因为两个变量对应一个touple，即c =2,d = 1
4. 以上过程就是先封装，再解构


## 定义

### 封装(装箱)

- 将多个值用逗号分割，组合在一起
- 本质上就是返回一个元组，只是省略了小括号


```python
t1 = (1,2) #定义为元组
t2 = 1，2 #将1和2封装为一个元组
```

### 解构(拆箱)

- 把线性解构的元素解开，并顺序的赋值给其他变量
- 左边接纳的变量数要和右边解开的元素的个数一致


```python
>>> a,b = (1,2)
>>> a
1
>>> b
2
```


### 对于非线性解构也没有问题

```python
>>> a,b = {'a':11, 'b':22}
>>> a
'a'
>>> b
'b'
>>> type(a)
<class 'str'>
```

可以看到，只是把字典的key带出来了，value没有带出来


## 剩余参数

可以理解为贪婪模式

```python
>>> a,*b = range(10)
>>> a
0
>>> b
[1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> a,*b,c = range(10)
>>> a,b,c
(0, [1, 2, 3, 4, 5, 6, 7, 8], 9)
```

## 嵌套模式的解构

```python
>>> a,b,c = [1,[2,3],4]
>>> a,b,c
(1, [2, 3], 4)

# 怎么得到嵌套结构的2，3
>>> a,[b,c],d = [1,[2,3],4]
>>> a,b,c,d
(1, 2, 3, 4)

# 注意*为贪婪模式，挑剩下的，没有也得接着
>>> a,*b,c = [1,2]
>>> a
1
>>> b
[]
>>> c
2
```

## 丢弃变量

- 这是一个惯例，是一个不成文的约定，不是标准
- 如果不关心这个变量，就可以用`_`表示
- `_`是一个合法的标识符，也可以作为一个有效的变量来用，但是一般定义这个变量为`_`就默认这个是丢弃变量

### 举例

```python
>>> a,b,c = (1,2,3)
>>> a,b,c
(1, 2, 3)
>>> a,_,c = (1,2,3)
>>> a,_,c
(1, 2, 3)
>>> a,*_,c = range(10)
>>> a,_,c
(0, [1, 2, 3, 4, 5, 6, 7, 8], 9)
```

