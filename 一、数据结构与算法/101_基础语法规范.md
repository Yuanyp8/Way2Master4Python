
* [注释](#注释)
         * [单行注释](#单行注释)
             * [多行注释](#多行注释)
     
      * [核心数据类型](#核心数据类型)
         * [数字](#数字)
            * [整数](#整数)
               * [字面量显示格式](#字面量显示格式)
            * [浮点数](#浮点数)
            * [复数](#复数)
         * [字符串](#字符串)
            * [序列操作](#序列操作)
               * [正向索引](#正向索引)
               * [反向索引](#反向索引)
               * [切片](#切片)
               * [字符串拼接](#字符串拼接)
            * [字符串不可变性](#字符串不可变性)
            * [三引号](#三引号)
            * [r前缀](#r前缀)
            * [f前缀](#f前缀)
         * [bool](#bool)





## 注释

### 单行注释

单行住释用`#`表示,如下
```
# this is comments
print('Hello World')
```

### 多行注释

多行注释用`"""`包围起来，如下

```
"""
this is multiline comments
"
\
/
"""
```

## 核心数据类型

|对象类型|字面量/构造示例|
|:--|-|
|数字|1234, 3.14.15, 3+4j, `0b1111`, Decimal(), Fraction()|
|字符串|'spam', "Bob's", b'a\x01c', u'sp\xc4m'|
|列表|[1, [2,  'three'], 4.5], list(range(10))|
|元组|(1, 'spam', 4, 'U'), tuple('spam'), nametuple|
|字典|{'foo': 'bar', 'color': 'yello'}, dict(hours=10)|
|集合|set('abc'), {'a', 'b', 'c'}|
| 文件         | open('egg.txt'), open(r'C:\ham.bin', 'wb')           |
| 其他核心类型 |类型、None、True、False|

### 数字

#### 整数

- Python2.X中的整数：**一般整数和长整数**

  Python2.X中有两种整数类型：一般整数（通常32位）和长整数（无限精度），并且一个整数可以以`l`或者`L`结尾，从而强制它转换为长整数。由于当整数的值超过为其分配的位数的时候回奏定转换为长整数，因此永远不用自己输入`L`。

- Python3.X中的整数：**单独的一种类型**

  在Python3.X中，一般整数和长整数已经合二为一了------只有整数这一种类型，它自动支持长整数类型中的无限精度。这一修改并不会影响到到多数程序，除非某些代码通过类型测试检测了Python2.X中的长整数。




```
>>> type(100)
<class 'int'>
>>> type(10000000000000000)
<class 'int'>
>>> type(0b1111)
<class 'int'>
```

##### 字面量显示格式

整数可以编写为十进制、十六进制、八进制和二进制形式。

- 十六进制整数以`0x`或`0X`开始，后面接十六进制的数字`0-9`和`A-F`。十六进制的数字编写成大写或小写都可以
- 八进制数据字面量以数字`0o` 或`0O`表示，后面接着数字`0-7`
- 二进制以`0b`或`0B`表示，后接数字`0-1`

记住，下面这些字面量只是指定一个整数对象的值的一种替代方法。例如，在Python3.X和Python2.X中编写的如下字面量回产生具有上述三种进制底数的常规整数。**在内存中，同一个整数的值是相同的，它与我们未来指定他二使用的底数无关**

```python
>>> 0o1,0o20,0o377
(1, 16, 255)
>>> 0x01,0x10,0xFF
(1, 16, 255)
>>> 0b1,0b10000,0b11111111
(1, 16, 255)
```

转化为十进制

```python
>>> 0xFF, (15 * (16 ** 1) + 15 * (16 ** 0))
(255, 255)
>>> 0x2F, (2 * (16 ** 1) + 15 * (16 ** 0))
(47, 47)
>>> 0xF, 0b1111, (1*(2**3) + 1*(2**2) + 1*(2**1) + 1*(2**0))
(15, 15, 15)
```



#### 浮点数

浮点数在标准CPython中采用C语言中的`双精度`来实现，因此，其精度与用来构建Python解释器的C编译器所给定的双精度一样。

```
>>> type(0.423432)
<class 'float'>
```

#### 复数

Python的复数字面量写成实部+虚部的写法，这里虚部是以`j`或`J`结尾。

`1+2j`

```
>>> type (1 + 2j)
<class 'complex'>
```



### 字符串

字符串用来记录文本信息和任意字节的集合。它们是我们在Python中提到的第一个作为序列的例子。序列中的元素包含了一个从左到右的顺序--序列中的元素根据他们的相对位置进行存储和读取。从严格意义上上说，字符串是由单字符的字符串所组成的序列。

简单来说，字符串使用`"`或者`'`包起来的字符序列

```
>>> c = "2"
>>> type(c)
<class 'str'>
```

#### 序列操作

作为序列，字符串支持假设其中各个元素包含位置顺序的操作。例如，如果我们有一个包含在一对引号内的四个字符的字符串，可使用内置的`len`函数验证其长度，并通过索引得到各个元素：

##### 正向索引
在Python中，索引是按照从左到右，从0开始来计算的。
```
>>> S = 'spam'
>>> len(S)  # Length
4
>>> S[0]  # The first item in S
's'
>>> S[1]
'p'
```

##### 反向索引
Python也支持反向索引，从最后一个开始（正向索引是从左边开始计算，反向索引是从右边开始计算）。
```
>>> S[-1]
'm'
>>> S[-2]
'a'
```

##### 切片
序列也支持切片（slice）操作，这是一种一步就能够提取整个分片的方法，例如
```
>>> S
'spam'
>>> S[0:2]
'sp'
```
> 切片是左闭右开原则

在一个分片中，左边界默认为0，并且右边界默认为分片序列的长度。这引入了一些常用方法:
```
>>> S
'spam'
>>> S[1:]  
'pam'
>>> S[0:3]
'spa'
>>> S[:-1]
'spa'
>>> S[:]
'spam'
>>> S[::-1]
'maps'
```
##### 字符串拼接
字符串也支持使用加号进行拼接
> 注意:字符串是不可变序列，拼接后返回一个新的字符串序列
```
>>> S
'spam'
>>> S+'abc'
'spamabc'
>>> S
'spam'
```

#### 字符串不可变性
字符串在Python中具有不可变性————在创建后不能改变原位置。换句话说，不能覆盖不可变对象的值。例如，不能通过对某一位置进行赋值而改变字符串，但你可以建立一个新的字符串并以同一个变量名称对其进行赋值。因为Python在运行过程中会清理旧的是对象

```
>>> S
'spam'
>>> S[0] = 'z'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> S = 'z'+ S[1:]
>>> S
'zpam'
```


可以将字符串扩展成独立字符构成的列表，然后重新拼接后再次构建；另一种改变方法就是batearry类型去改变字符串
```
>>> S = 'shrubbery'
>>> L = list(S)
>>> L
['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y']
>>> L[1] = 'c'
>>> ''.join(L)
'scrubbery'

>>> B = bytearray(b'spam')
>>> B.extend(b'eggs')
>>> B
bytearray(b'spameggs')
>>> B.decode()
'spameggs'
```


#### 三引号

三引号是python引进的一种用法，分为`"""`和`'''`
在三引号中可以随意的使用和添加单/双引号和换行符等

```
>>> type(''' 我是字符串‘"'" ''')
<class 'str'>
```

#### r前缀

在字符串前面加上`r`或者`R`前缀，表示该字符串不做特殊处理

```
>>> print(r'abc\n123')
abc\n123
>>> print('abc\n123')
abc
123
```

#### f前缀

在字符串前面加上`f`前缀，格式化字符串，仅支持3.6版本以上


### bool

bool值也是整数类,True等同1、False等同0

```
>>> type(True)
<class 'bool'>
>>> type(False)
<class 'bool'>
```
