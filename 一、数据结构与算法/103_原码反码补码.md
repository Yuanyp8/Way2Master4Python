* [原码](#原码)
         * [正数的原码](#正数的原码)
         * [负数的原码](#负数的原码)
      * [反码](#反码)
         * [正数的反码](#正数的反码)
         * [负数的反码](#负数的反码)
      * [补码](#补码)
         * [正数的补码](#正数的补码)
         * [负数的补码](#负数的补码)
      * [计算机中整数以补码的形式存储](#计算机中整数以补码的形式存储)

> 计算机的所有数据在底层都是以二进制的补码形式存储
> ***进制转换的时候需要先把内存存储的补码拿出来变成原码在进行转换输出***

## 原码

如 `4 = 0b0100`、`8 = 0b1000`

### 正数的原码

正数的原码就是其本身
`1的原码就是00000001(补齐8位)`

### 负数的原码

原码等于原码符号位不变，其余各位取反

```
-1 的原码
将1的原码的第一位取反，表示负

+1 = 00000001
-1 = 10000001
```

## 反码

###  正数的反码

正数的反码和原码一样

### 负数的反码

负数的反码，第一位不变，其余取反

```
+1 的原码 = 00000001
+1 的反码 = 00000001

-1 的原码 = 10000001
-1 的反码 = 11111110

```

## 补码

### 正数的补码

正数的补码也是其本身

### 负数的补码

在原码的基础上除符号位外其余位取反后+1

```
+1 的原码 = 00000001
+1 的反码 = 00000001
+1 的补码 = 00000001

-1 的原码 = 10000001
-1 的反码 = 11111110
-1 的补码 = 11111111(即FF)
```

>正数的反码原码补码都是一样的，负数的补码等于反码加1，而反码等于原码符号位不变，其余各位取反;补码的补码就是原码

## 计算机中整数以补码的形式存储

为了简化计算机基本运算电路，使得加减法运算都用加法解决。于是改变负数存储的形式，存储成一种可以直接当成正数来相加的形式，这种形式就是补码。（正数不用变，所以接下来的讨论中一般略去正数）

```
  5 - 1
= 5 + (-1)
= 00000101 + 11111111
=  00000101
   11111111 +
---------------
= 100000100 (1为溢出位)
=  00000100
=  4
```


